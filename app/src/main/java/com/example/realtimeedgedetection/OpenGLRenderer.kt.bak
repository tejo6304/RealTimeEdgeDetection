package com.example.realtimeedgedetection

import android.graphics.Bitmap
import android.opengl.GLES20
import android.opengl.GLSurfaceView
import android.util.Log
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.FloatBuffer
import javax.microedition.khronos.egl.EGLConfig
import javax.microedition.khronos.opengles.GL10
import kotlin.math.sqrt

/**
 * OpenGL ES 2.0 renderer for GPU-accelerated image filtering
 * Provides high-performance real-time rendering with texture streaming
 */
class OpenGLRenderer(
    glSurfaceView: GLSurfaceView?,
    private val initCallback: (Boolean) -> Unit
) : GLSurfaceView.Renderer {

    companion object {
        private const val TAG = "OpenGLRenderer"
        private const val BYTES_PER_FLOAT = 4

        // Vertex Shader
        private const val VERTEX_SHADER = """
            #version 100
            attribute vec4 vPosition;
            attribute vec2 vTexCoord;
            varying vec2 texCoord;
            
            void main() {
                gl_Position = vPosition;
                texCoord = vTexCoord;
            }
        """

        // Fragment Shaders
        private const val FRAGMENT_SHADER_ORIGINAL = """
            #version 100
            precision mediump float;
            varying vec2 texCoord;
            uniform sampler2D sTexture;
            
            void main() {
                gl_FragColor = texture2D(sTexture, texCoord);
            }
        """

        private const val FRAGMENT_SHADER_GRAYSCALE = """
            #version 100
            precision mediump float;
            varying vec2 texCoord;
            uniform sampler2D sTexture;
            
            void main() {
                vec4 color = texture2D(sTexture, texCoord);
                float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                gl_FragColor = vec4(gray, gray, gray, color.a);
            }
        """

        private const val FRAGMENT_SHADER_CANNY = """
            #version 100
            precision mediump float;
            varying vec2 texCoord;
            uniform sampler2D sTexture;
            uniform vec2 texSize;
            
            void main() {
                vec2 texel = 1.0 / texSize;
                
                vec3 c0 = texture2D(sTexture, texCoord + vec2(-1.0, -1.0) * texel).rgb;
                vec3 c1 = texture2D(sTexture, texCoord + vec2( 0.0, -1.0) * texel).rgb;
                vec3 c2 = texture2D(sTexture, texCoord + vec2( 1.0, -1.0) * texel).rgb;
                
                vec3 c3 = texture2D(sTexture, texCoord + vec2(-1.0,  0.0) * texel).rgb;
                vec3 c5 = texture2D(sTexture, texCoord + vec2( 1.0,  0.0) * texel).rgb;
                
                vec3 c6 = texture2D(sTexture, texCoord + vec2(-1.0,  1.0) * texel).rgb;
                vec3 c7 = texture2D(sTexture, texCoord + vec2( 0.0,  1.0) * texel).rgb;
                vec3 c8 = texture2D(sTexture, texCoord + vec2( 1.0,  1.0) * texel).rgb;
                
                vec3 sobelX = -c0 - 2.0 * c3 - c6 + c2 + 2.0 * c5 + c8;
                vec3 sobelY = -c0 - 2.0 * c1 - c2 + c6 + 2.0 * c7 + c8;
                
                vec3 edge = sqrt(sobelX * sobelX + sobelY * sobelY);
                gl_FragColor = vec4(edge, 1.0);
            }
        """
    }

    private var glSurfaceView: GLSurfaceView? = glSurfaceView
    private var programOriginal = 0
    private var programGrayscale = 0
    private var programCanny = 0
    private var currentProgram = 0

    private var positionHandle = 0
    private var texCoordHandle = 0
    private var samplerHandle = 0
    private var texSizeUniformHandle = 0

    private var textureId = 0
    private var frameBufferObject = 0
    private var renderTexture = 0
    
    private var surfaceWidth = 0
    private var surfaceHeight = 0
    private var isInitialized = false

    private lateinit var vertexBuffer: FloatBuffer
    private lateinit var texCoordBuffer: FloatBuffer

    init {
        glSurfaceView?.apply {
            setEGLContextClientVersion(2)
            setRenderer(this@OpenGLRenderer)
            renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY
        }
        Log.d(TAG, "OpenGLRenderer initialized")
    }

    override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) {
        Log.d(TAG, "onSurfaceCreated called")
        
        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)
        GLES20.glEnable(GLES20.GL_BLEND)
        GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA)

        try {
            programOriginal = createProgram(VERTEX_SHADER, FRAGMENT_SHADER_ORIGINAL)
            programGrayscale = createProgram(VERTEX_SHADER, FRAGMENT_SHADER_GRAYSCALE)
            programCanny = createProgram(VERTEX_SHADER, FRAGMENT_SHADER_CANNY)
            
            currentProgram = programOriginal
            setupBuffers()

            Log.d(TAG, "Shaders compiled successfully")
            isInitialized = true
            initCallback(true)

        } catch (e: Exception) {
            Log.e(TAG, "Shader compilation failed: ${e.message}", e)
            initCallback(false)
        }
    }

    override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) {
        Log.d(TAG, "onSurfaceChanged: $width x $height")
        surfaceWidth = width
        surfaceHeight = height
        GLES20.glViewport(0, 0, width, height)
        createFramebuffer(width, height)
    }

    override fun onDrawFrame(gl: GL10?) {
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT or GLES20.GL_DEPTH_BUFFER_BIT)
        
        if (!isInitialized) {
            return
        }
        renderQuad()
    }

    private fun setupBuffers() {
        val vertices = floatArrayOf(
            -1.0f, -1.0f,
            1.0f, -1.0f,
            -1.0f, 1.0f,
            1.0f, 1.0f
        )

        val texCoords = floatArrayOf(
            0.0f, 1.0f,
            1.0f, 1.0f,
            0.0f, 0.0f,
            1.0f, 0.0f
        )

        vertexBuffer = ByteBuffer.allocateDirect(vertices.size * BYTES_PER_FLOAT)
            .order(ByteOrder.nativeOrder()).asFloatBuffer()
            .put(vertices).apply { position(0) }

        texCoordBuffer = ByteBuffer.allocateDirect(texCoords.size * BYTES_PER_FLOAT)
            .order(ByteOrder.nativeOrder()).asFloatBuffer()
            .put(texCoords).apply { position(0) }
    }

    private fun renderQuad() {
        if (currentProgram == 0 || textureId == 0) {
            return
        }

        GLES20.glUseProgram(currentProgram)

        positionHandle = GLES20.glGetAttribLocation(currentProgram, "vPosition")
        texCoordHandle = GLES20.glGetAttribLocation(currentProgram, "vTexCoord")
        samplerHandle = GLES20.glGetUniformLocation(currentProgram, "sTexture")
        texSizeUniformHandle = GLES20.glGetUniformLocation(currentProgram, "texSize")

        GLES20.glEnableVertexAttribArray(positionHandle)
        vertexBuffer.position(0)
        GLES20.glVertexAttribPointer(positionHandle, 2, GLES20.GL_FLOAT, false, 8, vertexBuffer)

        GLES20.glEnableVertexAttribArray(texCoordHandle)
        texCoordBuffer.position(0)
        GLES20.glVertexAttribPointer(texCoordHandle, 2, GLES20.GL_FLOAT, false, 8, texCoordBuffer)

        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId)
        GLES20.glUniform1i(samplerHandle, 0)

        if (texSizeUniformHandle != -1) {
            GLES20.glUniform2f(texSizeUniformHandle, surfaceWidth.toFloat(), surfaceHeight.toFloat())
        }

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)

        GLES20.glDisableVertexAttribArray(positionHandle)
        GLES20.glDisableVertexAttribArray(texCoordHandle)
    }

    fun setFilterType(filterType: Int) {
        currentProgram = when (filterType) {
            0 -> programGrayscale
            1 -> programCanny
            else -> programOriginal
        }
        Log.d(TAG, "Filter type set to: $filterType")
    }

    fun updateTexture(bitmap: Bitmap) {
        if (textureId == 0) {
            val textures = IntArray(1)
            GLES20.glGenTextures(1, textures, 0)
            textureId = textures[0]
        }

        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)

        android.opengl.GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0)
    }

    private fun createProgram(vertexSource: String, fragmentSource: String): Int {
        val vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource)
        val fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource)

        val program = GLES20.glCreateProgram()
        GLES20.glAttachShader(program, vertexShader)
        GLES20.glAttachShader(program, fragmentShader)
        GLES20.glLinkProgram(program)

        val linkStatus = IntArray(1)
        GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0)

        if (linkStatus[0] == 0) {
            Log.e(TAG, "Shader program linking failed: ${GLES20.glGetProgramInfoLog(program)}")
            GLES20.glDeleteProgram(program)
            return 0
        }

        return program
    }

    private fun loadShader(type: Int, shaderSource: String): Int {
        val shader = GLES20.glCreateShader(type)
        GLES20.glShaderSource(shader, shaderSource)
        GLES20.glCompileShader(shader)

        val compileStatus = IntArray(1)
        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compileStatus, 0)

        if (compileStatus[0] == 0) {
            Log.e(TAG, "Shader compilation failed: ${GLES20.glGetShaderInfoLog(shader)}")
            GLES20.glDeleteShader(shader)
            return 0
        }

        return shader
    }

    private fun createFramebuffer(width: Int, height: Int) {
        val textures = IntArray(1)
        GLES20.glGenTextures(1, textures, 0)
        renderTexture = textures[0]

        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, renderTexture)
        GLES20.glTexImage2D(
            GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA,
            width, height, 0,
            GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null
        )
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)

        val framebuffers = IntArray(1)
        GLES20.glGenFramebuffers(1, framebuffers, 0)
        frameBufferObject = framebuffers[0]

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBufferObject)
        GLES20.glFramebufferTexture2D(
            GLES20.GL_FRAMEBUFFER,
            GLES20.GL_COLOR_ATTACHMENT0,
            GLES20.GL_TEXTURE_2D,
            renderTexture, 0
        )

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)
    }

    fun cleanup() {
        try {
            if (programOriginal != 0) GLES20.glDeleteProgram(programOriginal)
            if (programGrayscale != 0) GLES20.glDeleteProgram(programGrayscale)
            if (programCanny != 0) GLES20.glDeleteProgram(programCanny)
            if (frameBufferObject != 0) GLES20.glDeleteFramebuffers(1, intArrayOf(frameBufferObject), 0)
            if (renderTexture != 0) GLES20.glDeleteTextures(1, intArrayOf(renderTexture), 0)
            if (textureId != 0) GLES20.glDeleteTextures(1, intArrayOf(textureId), 0)

            Log.d(TAG, "OpenGL resources cleaned up")
        } catch (e: Exception) {
            Log.e(TAG, "Error during cleanup: ${e.message}", e)
        }
    }
}
